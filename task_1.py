"""
На языке Python написать алгоритм (функцию) определения четности целого числа, 
который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. 
Объяснить плюсы и минусы обеих реализаций. 
Пример: 
def isEven(value):
      return value % 2 == 0
"""

import time


def isEven(value) -> bool:
    """
    Код из примераю
    Проводится деление с остатком.
    value: число для проверки четности.
    return: True - если остаток от деления равен 0.
            False - если остаток от деления равен 1.

    Плюсы:  1. Код понятный всем;
    Минусы: 1. Медленнее, в сравнении с побитовой операцией.
    """
    return value % 2 == 0


def bitwise_is_even(value: int) -> bool:
    """
    Проводится побитовая операция логического умножения.
    value: число для проверки четности.
    return: True - если в результате логического умножения младший бит равен 0.
            False - если в результате логического умножения младший бит равен 1.

    Плюсы:  1. Быстрее операции взятия остатка от деления.
    Минусы: 1. В сравнении с функцией, где берется остаток от деления - код не такой понятный и хорошо читаемый.
    """
    if value & 1 == 0:
        return True
    else:
        return False


"""
Вы также можете проверить различия во времени выполнения этих двух функций и увидеть, что 
в подавляющем большинстве случаев - функция bitwise_is_even оказывается быстрее.
"""

test_arr = [
    -1, -2, -3, -4, -5, -6, -7, -8, -9, -0,
    1000000, 1000001, 10000000000, 10000000001,
    100000000000000000000000000000000000000000,
    100000000000000000000000000000000000000000000000000000000000000000000000000000000000,
    123876237814873462035034895729472398756928409137498234579283472398579834572398472398,
    283742435729348394857948209348394857283029437893245702938420939579348752803742390477
]  # Тестовый массив целых чисел.

for i in test_arr:
    start_time = time.perf_counter_ns()
    isEven(i)
    stop_time = time.perf_counter_ns()
    print(f'isEven: {stop_time-start_time}')
    start_time = time.perf_counter_ns()
    bitwise_is_even(i)
    stop_time = time.perf_counter_ns()
    print(f'bitwise_is_even: {stop_time-start_time}')
